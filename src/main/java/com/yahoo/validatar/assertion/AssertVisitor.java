/*
 * Copyright 2017 Yahoo Inc.
 * Licensed under the terms of the Apache 2 license. Please see LICENSE file in the project root for terms.
 */
package com.yahoo.validatar.assertion;

import com.yahoo.validatar.assertion.Expression.BinaryColumnOperation;
import com.yahoo.validatar.assertion.Expression.UnaryColumnOperation;
import com.yahoo.validatar.common.Column;
import com.yahoo.validatar.common.Operations;
import com.yahoo.validatar.common.Result;
import com.yahoo.validatar.common.TypeSystem;
import com.yahoo.validatar.common.TypedObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringEscapeUtils;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

/**
 * Handles evaluating the parsed Assertion parse tree generated by ANTLR. Evaluating it
 */
@Slf4j
public class AssertVisitor extends GrammarBaseVisitor<Expression> {
    // These are read-only (including values)! Do not modify ever!
    private final Result allData;
    private final List<Result> results;

    // These can change per assert.
    @Getter
    private Result joinedResult;
    @Getter
    private Set<String> seenIdentifiers;

    private Column getColumnValue(Result result, String name) {
        Map<String, Column> columns = result.getColumns();
        // Check for no mapping explicitly
        if (!columns.containsKey(name)) {
            log.error("Column not found: {}.\nAvailable Columns: {}", name, columns.keySet());
            throw new NoSuchElementException("Unable to find value for column: " + name + " in results");
        }
        Column column = columns.get(name).copy();
        return column;
    }

    private static String stripQuotes(String literal) {
        return literal.substring(1, literal.length() - 1);
    }

    // This helper function matches the UnaryColumnOperation functional interface
    private static Column negate(Column column) {
        Column negativeOnes = TypeSystem.asColumn(TypeSystem.asTypedObject(-1L), column.size());
        return TypeSystem.perform(Operations.BinaryOperation.MULTIPLY, negativeOnes, column);
    }

    // Helper to partially apply perform
    private static UnaryColumnOperation curry(Operations.UnaryOperation operation) {
        return input -> TypeSystem.perform(operation, input);
    }

    // Helper to partially apply perform
    private static BinaryColumnOperation curry(Operations.BinaryOperation operation) {
        return (a, b) -> TypeSystem.perform(operation, a, b);
    }

    private static List<Result> findDataSetsToJoin(Set<String> seenIdentifiers, List<Result> results) {
        List<Result> datasets = new ArrayList<>();
        Set<String> resultSets = new HashSet<>();
        for (String identifier : seenIdentifiers) {
            Optional<Result> result = results.stream().filter(r -> r.hasQualifiedColumn(identifier)).findFirst();
            if (!result.isPresent()) {
                log.error("Identifier {} used in join expression not found in results {}", identifier, datasets);
                throw new RuntimeException("Could not find the result for " + identifier + " to perform the join.");
            }
            Result toAdd = result.get();
            String name = toAdd.getNamespace();
            if (!resultSets.contains(name)) {
                resultSets.add(name);
                datasets.add(toAdd);
            }
        }
        return datasets;
    }

    /**
     * Creates a vistor to walk the assertion parse tree.
     *
     * @param results A non-null {@link List} of {@link Result}.
     */
    public AssertVisitor(List<Result> results) {
        Objects.requireNonNull(results);

        this.results = results;
        allData = results.stream().collect(Result::new, Result::merge, Result::merge);
        reset();
    }

    /**
     * Resets the visited state. Call after each walk from the top-level statement.
     */
    public void reset() {
        seenIdentifiers = new HashSet<>();
        joinedResult = new Result();
    }

    @Override
    public Expression visitTruthy(GrammarParser.TruthyContext context) {
        String bool = context.getText();
        return Expression.wrap(TypeSystem.asTypedObject(Boolean.valueOf(bool)));
    }

    @Override
    public Expression visitWholeNumber(GrammarParser.WholeNumberContext context) {
        String text = context.getText();
        TypedObject object;
        try {
            object = TypeSystem.asTypedObject(Long.valueOf(text));
        } catch (NumberFormatException nfe) {
            log.info("Integer could not be parsed as a Long: {}. Trying BigDecimal...", text);
            object = TypeSystem.asTypedObject(new BigDecimal(text));
        }
        return Expression.wrap(object);
    }

    @Override
    public Expression visitDecimalNumber(GrammarParser.DecimalNumberContext context) {
        String text = context.getText();
        TypedObject object;
        Double value = Double.valueOf(text);
        // Can't be NaN since our parser ensures only valid digits and decimal
        if (value.isInfinite()) {
            log.info("Number could not be parsed as a Double: {}. Trying BigDecimal...", text);
            object = TypeSystem.asTypedObject(new BigDecimal(text));
        } else  {
            object = TypeSystem.asTypedObject(value);
        }
        return Expression.wrap(object);
    }

    // No need to override anything that only has exactly one child node (including terminal nodes)

    @Override
    public Expression visitStringValue(GrammarParser.StringValueContext context) {
        String text = context.getText();
        return Expression.wrap(TypeSystem.asTypedObject(StringEscapeUtils.unescapeJava(stripQuotes(text))));
    }

    @Override
    public Expression visitIdentifier(GrammarParser.IdentifierContext context) {
        String text = context.getText();
        seenIdentifiers.add(text);
        // We want to return an expression which will pull the value from a data set that we will pass in later.
        return new Expression(data -> getColumnValue(data, text));
    }

    @Override
    public Expression visitApproxValue(GrammarParser.ApproxValueContext context) {
        Expression a = visit(context.l);
        Expression b = visit(context.r);
        Expression percent = visit(context.p);
        return new Expression(data -> TypeSystem.approx(a.evaluate(data), b.evaluate(data), percent.evaluate(data)));
    }

    @Override
    public Expression visitParenthesizedValue(GrammarParser.ParenthesizedValueContext context) {
        return visit(context.orExpression());
    }

    @Override
    public Expression visitNegateValue(GrammarParser.NegateValueContext context) {
        Expression expression = visit(context.baseExpression());
        boolean hasMinus = context.MINUS() != null;
        return hasMinus ? Expression.compose(AssertVisitor::negate, expression) : expression;
    }

    @Override
    public Expression visitLogicalNegateValue(GrammarParser.LogicalNegateValueContext context) {
        Expression expression = visit(context.baseExpression());
        return Expression.compose(curry(Operations.UnaryOperation.NOT), expression);
    }

    @Override
    public Expression visitMultiplyValue(GrammarParser.MultiplyValueContext context) {
        Expression left = visit(context.multiplicativeExpression());
        Expression right = visit(context.unaryExpression());
        return Expression.compose(curry(Operations.BinaryOperation.MULTIPLY), left, right);
    }

    @Override
    public Expression visitDivideValue(GrammarParser.DivideValueContext context) {
        Expression left = visit(context.multiplicativeExpression());
        Expression right = visit(context.unaryExpression());
        return Expression.compose(curry(Operations.BinaryOperation.DIVIDE), left, right);
    }

    @Override
    public Expression visitModValue(GrammarParser.ModValueContext context) {
        Expression left = visit(context.multiplicativeExpression());
        Expression right = visit(context.unaryExpression());
        return Expression.compose(curry(Operations.BinaryOperation.MODULUS), left, right);
    }

    @Override
    public Expression visitAddValue(GrammarParser.AddValueContext context) {
        Expression left = visit(context.additiveExpression());
        Expression right = visit(context.multiplicativeExpression());
        return Expression.compose(curry(Operations.BinaryOperation.ADD), left, right);
    }

    @Override
    public Expression visitSubtractValue(GrammarParser.SubtractValueContext context) {
        Expression left = visit(context.additiveExpression());
        Expression right = visit(context.multiplicativeExpression());
        return Expression.compose(curry(Operations.BinaryOperation.SUBTRACT), left, right);
    }

    @Override
    public Expression visitGreaterValue(GrammarParser.GreaterValueContext context) {
        Expression left = visit(context.relationalExpression());
        Expression right = visit(context.additiveExpression());
        return Expression.compose(curry(Operations.BinaryOperation.GREATER), left, right);
    }

    @Override
    public Expression visitLessValue(GrammarParser.LessValueContext context) {
        Expression left = visit(context.relationalExpression());
        Expression right = visit(context.additiveExpression());
        return Expression.compose(curry(Operations.BinaryOperation.LESS), left, right);
    }

    @Override
    public Expression visitLessEqualValue(GrammarParser.LessEqualValueContext context) {
        Expression left = visit(context.relationalExpression());
        Expression right = visit(context.additiveExpression());
        return Expression.compose(curry(Operations.BinaryOperation.LESS_EQUAL), left, right);
    }

    @Override
    public Expression visitGreaterEqualValue(GrammarParser.GreaterEqualValueContext context) {
        Expression left = visit(context.relationalExpression());
        Expression right = visit(context.additiveExpression());
        return Expression.compose(curry(Operations.BinaryOperation.GREATER_EQUAL), left, right);
    }

    @Override
    public Expression visitEqualityValue(GrammarParser.EqualityValueContext context) {
        Expression left = visit(context.equalityExpression());
        Expression right = visit(context.relationalExpression());
        return Expression.compose(curry(Operations.BinaryOperation.EQUAL), left, right);
    }

    @Override
    public Expression visitNotEqualityValue(GrammarParser.NotEqualityValueContext context) {
        Expression left = visit(context.equalityExpression());
        Expression right = visit(context.relationalExpression());
        return Expression.compose(curry(Operations.BinaryOperation.NOT_EQUAL), left, right);
    }

    @Override
    public Expression visitAndValue(GrammarParser.AndValueContext context) {
        Expression left = visit(context.andExpression());
        Expression right = visit(context.equalityExpression());
        return Expression.compose(curry(Operations.BinaryOperation.AND), left, right);
    }

    @Override
    public Expression visitOrValue(GrammarParser.OrValueContext context) {
        Expression left = visit(context.orExpression());
        Expression right = visit(context.andExpression());
        return Expression.compose(curry(Operations.BinaryOperation.OR), left, right);
    }

    @Override
    public Expression visitBaseOrValue(GrammarParser.BaseOrValueContext context) {
        Expression assertion = visit(context.orExpression());

        // No join to do when just assertion
        joinedResult = allData;

        return Expression.wrap(assertion.evaluate(joinedResult));
    }

    @Override
    public Expression visitJoinValue(GrammarParser.JoinValueContext context) {
        // Visit and build the expression tree for the join expression
        Expression join = visit(context.j);

        // Do the same for the assert statement
        Expression assertion = visit(context.o);

        // All identifiers seen so far indicate the results we need to join
        List<Result> resultsToJoin = findDataSetsToJoin(seenIdentifiers, results);

        // Use those results to do a cartesian product.
        log.info("Starting joins on {}", resultsToJoin);
        Result cartesianProduct = Result.cartesianProduct(resultsToJoin);

        // Evaluate the join expression on the cartesian product
        Column joinResult = join.evaluate(cartesianProduct);

        // The rows for which the expression is true have successfully joined
        joinedResult = Result.join(cartesianProduct, joinResult);
        log.info("Joined dataset for assertion: \n{}", joinedResult.prettyPrint());

        // Evaluate the assert statement using the joined data and return the result as an expression.
        return Expression.wrap(assertion.evaluate(joinedResult));
    }
}
