package com.yahoo.validatar.assertion;

import com.yahoo.validatar.common.Column;
import com.yahoo.validatar.common.Result;
import com.yahoo.validatar.common.TypeSystem;
import com.yahoo.validatar.common.TypeSystem.Type;
import com.yahoo.validatar.common.TypedObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringEscapeUtils;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;

import static com.yahoo.validatar.common.TypeSystem.approx;
import static com.yahoo.validatar.common.TypeSystem.asTypedObject;
import static com.yahoo.validatar.common.TypeSystem.negate;

/**
 * Handles evaluating the parsed Assertion parse tree generated by ANTLR.
 */
@Slf4j
public class AssertVisitor extends GrammarBaseVisitor<Expression> {
    // These are read-only (including values)! Do not modify ever!
    private final Map<String, Column> columns;
    private final Map<String, Map<String, Column>> datasets;

    // These change per assert.
    @Getter
    private Map<String, String> examinedColumns;
    private Map<String, Column> joinedColumns;

    private static String stripQuotes(String literal) {
        return literal.substring(1, literal.length() - 1);
    }

    private Column getColumnValue(Map<String, Column> columns, String name) {
        // Check for no mapping explicitly
        if (!columns.containsKey(name)) {
            log.error("Column not found: {}.\nAvailable Columns: {}", name, columns.keySet());
            throw new NoSuchElementException("Unable to find value for column: " + name + " in results");
        }
        Column result = columns.get(name);
        examinedColumns.put(name, Objects.toString(result));
        return result;
    }

    /**
     * Creates a vistor to walk the assertion parse tree.
     *
     * @param results A non-null {@link List} of {@link Result}.
     */
    public AssertVisitor(List<Result> results) {
        Objects.requireNonNull(results);

        datasets = new HashMap<>();
        examinedColumns = new HashMap<>();
        joinedColumns = new HashMap<>();

        Result merged = new Result();
        for (Result result : results) {
            merged.merge(result);
            datasets.put(result.getNamespace(), result.getColumns());
        }

        columns = merged.getColumns();
    }

    /**
     * Resets the visited state. Call after each walk from the top-level statement.
     */
    public void reset() {
        examinedColumns = new HashMap<>();
        joinedColumns = new HashMap<>();
    }

    @Override
    public Expression visitTruthy(GrammarParser.TruthyContext context) {
        String bool = context.getText();
        return Expression.wrap(asTypedObject(Boolean.valueOf(bool));
    }

    @Override
    public Expression visitWholeNumber(GrammarParser.WholeNumberContext context) {
        String text = context.getText();
        TypedObject object;
        try {
            object = asTypedObject(Long.valueOf(text));
        } catch (NumberFormatException nfe) {
            log.info("Integer could not be parsed as a Long: {}. Trying BigDecimal...", text);
            object = asTypedObject(new BigDecimal(text));
        }
        return Expression.wrap(object);
    }

    @Override
    public Expression visitDecimalNumber(GrammarParser.DecimalNumberContext context) {
        String text = context.getText();
        TypedObject object;
        try {
            object = asTypedObject(Double.valueOf(text));
        } catch (NumberFormatException nfe) {
            log.info("Integer could not be parsed as a Double: {}. Trying BigDecimal...", text);
            object = asTypedObject(new BigDecimal(text));
        }
        return Expression.wrap(object);
    }

    @Override
    public Expression visitTruthValue(GrammarParser.TruthValueContext context) {
        return visit(context.truthy());
    }

    @Override
    public Expression visitNumericValue(GrammarParser.NumericValueContext context) {
        return visit(context.numeric());
    }

    @Override
    public Expression visitStringValue(GrammarParser.StringValueContext context) {
        String text = context.getText();
        return Expression.wrap(asTypedObject(StringEscapeUtils.unescapeJava(stripQuotes(text))));
    }

    @Override
    public Expression visitIdentifier(GrammarParser.IdentifierContext context) {
        String text = context.getText();
        // We want to return an expression which will pull the value from a data set that we will pass in later.
        return new Expression(data -> getColumnValue(data, text));
    }

    @Override
    public Expression visitApproxValue(GrammarParser.ApproxValueContext context) {
        Expression a = visit(context.l);
        Expression b = visit(context.r);
        Expression percent = visit(context.p);
        return new Expression(data -> approx(a.evaluate(data), b.evaluate(data), percent.evaluate(data)));
    }

    @Override
    public Expression visitBaseValue(GrammarParser.BaseValueContext context) {
        return visit(context.base());
    }

    @Override
    public Expression visitFunctionalValue(GrammarParser.FunctionalValueContext context) {
        return visit(context.functionalExpression());
    }

    @Override
    public Expression visitParenthesizedValue(GrammarParser.ParenthesizedValueContext context) {
        return visit(context.orExpression());
    }

    @Override
    public Expression visitNegateValue(GrammarParser.NegateValueContext context) {
        Expression expression = visit(context.baseExpression());
        return new Expression(data -> negate(expression.evaluate(data)));
    }

    @Override
    public Expression visitLogicalNegateValue(GrammarParser.LogicalNegateValueContext ctx) {
        return super.visitLogicalNegateValue(ctx);
    }

    @Override
    public Expression visitDivideValue(GrammarParser.DivideValueContext context) {
        return super.visitDivideValue(context);
    }

    @Override
    public Expression visitBaseUnaryValue(GrammarParser.BaseUnaryValueContext context) {
        return super.visitBaseUnaryValue(context);
    }

    @Override
    public Expression visitMultiplyValue(GrammarParser.MultiplyValueContext context) {
        return super.visitMultiplyValue(context);
    }

    @Override
    public Expression visitModValue(GrammarParser.ModValueContext context) {
        return super.visitModValue(context);
    }

    @Override
    public Expression visitSubtractValue(GrammarParser.SubtractValueContext context) {
        return super.visitSubtractValue(context);
    }

    @Override
    public Expression visitBaseMultiplicativeValue(GrammarParser.BaseMultiplicativeValueContext context) {
        return visit(context.multiplicativeExpression());
    }

    @Override
    public Expression visitAddValue(GrammarParser.AddValueContext context) {
        return super.visitAddValue(context);
    }

    @Override
    public Expression visitLessValue(GrammarParser.LessValueContext context) {
        return super.visitLessValue(context);
    }

    @Override
    public Expression visitLessEqualValue(GrammarParser.LessEqualValueContext context) {
        return super.visitLessEqualValue(context);
    }

    @Override
    public Expression visitGreaterEqualValue(GrammarParser.GreaterEqualValueContext context) {
        return super.visitGreaterEqualValue(context);
    }

    @Override
    public Expression visitBaseAdditiveValue(GrammarParser.BaseAdditiveValueContext context) {
        return visit(context.additiveExpression());
    }

    @Override
    public Expression visitGreaterValue(GrammarParser.GreaterValueContext context) {
        return super.visitGreaterValue(context);
    }

    @Override
    public Expression visitEqualityValue(GrammarParser.EqualityValueContext context) {
        return super.visitEqualityValue(context);
    }

    @Override
    public Expression visitNotEqualityValue(GrammarParser.NotEqualityValueContext context) {
        return super.visitNotEqualityValue(context);
    }

    @Override
    public Expression visitBaseRelativeValue(GrammarParser.BaseRelativeValueContext context) {
        return visit(context.relationalExpression());
    }

    @Override
    public Expression visitBaseEqualityValue(GrammarParser.BaseEqualityValueContext context) {
        return visit(context.equalityExpression());
    }

    @Override
    public Expression visitAndValue(GrammarParser.AndValueContext context) {
        return super.visitAndValue(context);
    }

    @Override
    public Expression visitBaseAndValue(GrammarParser.BaseAndValueContext context) {
        return visit(context.andExpression());
    }

    @Override
    public Expression visitOrValue(GrammarParser.OrValueContext context) {
        return super.visitOrValue(context);
    }

    @Override
    public Expression visitBaseOrValue(GrammarParser.BaseOrValueContext context) {
        return visit(context.orExpression());
    }

    @Override
    public Expression visitJoinValue(GrammarParser.JoinValueContext context) {
        return super.visitJoinValue(context);
    }
}
